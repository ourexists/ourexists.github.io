<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>工业终端单应用锁屏实现（工业 Kiosk 模式应用） | OUREXISTS的博客</title><meta name="author" content="OUREXISTS"><meta name="copyright" content="OUREXISTS"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="工业领域 Kiosk 模式技术架构与实现实践一、什么是 Kiosk 模式Kiosk 模式（自助终端模式）是一种系统锁定运行环境，仅允许用户访问指定应用或页面的运行机制。 其核心目标：  限制用户操作范围 防止系统被修改或破坏 提供稳定可靠的人机交互入口 实现无人值守运行  在工业场景中，Kiosk 模式常作为 设备操作入口、监控终端、数据采集界面 的基础运行环境。  二、工业领域应用场景1. HM">
<meta property="og:type" content="article">
<meta property="og:title" content="工业终端单应用锁屏实现（工业 Kiosk 模式应用）">
<meta property="og:url" content="https://blog.ourexists.site/2026/02/23/kiosk/index.html">
<meta property="og:site_name" content="OUREXISTS的博客">
<meta property="og:description" content="工业领域 Kiosk 模式技术架构与实现实践一、什么是 Kiosk 模式Kiosk 模式（自助终端模式）是一种系统锁定运行环境，仅允许用户访问指定应用或页面的运行机制。 其核心目标：  限制用户操作范围 防止系统被修改或破坏 提供稳定可靠的人机交互入口 实现无人值守运行  在工业场景中，Kiosk 模式常作为 设备操作入口、监控终端、数据采集界面 的基础运行环境。  二、工业领域应用场景1. HM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.ourexists.site/img/bg.jpg">
<meta property="article:published_time" content="2026-02-23T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-26T08:35:53.074Z">
<meta property="article:author" content="OUREXISTS">
<meta property="article:tag" content="工业化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.ourexists.site/img/bg.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "工业终端单应用锁屏实现（工业 Kiosk 模式应用）",
  "url": "https://blog.ourexists.site/2026/02/23/kiosk/",
  "image": "https://blog.ourexists.site/img/bg.jpg",
  "datePublished": "2026-02-23T16:00:00.000Z",
  "dateModified": "2026-02-26T08:35:53.074Z",
  "author": [
    {
      "@type": "Person",
      "name": "OUREXISTS",
      "url": "https://blog.ourexists.site"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.ourexists.site/2026/02/23/kiosk/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: OUREXISTS","link":"链接: ","source":"来源: OUREXISTS的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '工业终端单应用锁屏实现（工业 Kiosk 模式应用）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/jishu/"><i class="fa-fw fas fa-tags"></i><span> 技术博客</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fa-heartbeat"></i><span> 开源项目</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 摄影影集</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-video"></i><span> 经典文案</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">OUREXISTS的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">工业终端单应用锁屏实现（工业 Kiosk 模式应用）</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/jishu/"><i class="fa-fw fas fa-tags"></i><span> 技术博客</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fa-heartbeat"></i><span> 开源项目</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 摄影影集</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-video"></i><span> 经典文案</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">工业终端单应用锁屏实现（工业 Kiosk 模式应用）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-02-23T16:00:00.000Z" title="发表于 2026-02-24 00:00:00">2026-02-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-26T08:35:53.074Z" title="更新于 2026-02-26 16:35:53">2026-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E4%B8%9A%E5%8C%96/">工业化</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E4%B8%9A%E5%8C%96/OS/">OS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">906</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>2分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="工业领域-Kiosk-模式技术架构与实现实践"><a href="#工业领域-Kiosk-模式技术架构与实现实践" class="headerlink" title="工业领域 Kiosk 模式技术架构与实现实践"></a>工业领域 Kiosk 模式技术架构与实现实践</h1><h2 id="一、什么是-Kiosk-模式"><a href="#一、什么是-Kiosk-模式" class="headerlink" title="一、什么是 Kiosk 模式"></a>一、什么是 Kiosk 模式</h2><p>Kiosk 模式（自助终端模式）是一种<strong>系统锁定运行环境</strong>，仅允许用户访问指定应用或页面的运行机制。</p>
<p>其核心目标：</p>
<ul>
<li>限制用户操作范围</li>
<li>防止系统被修改或破坏</li>
<li>提供稳定可靠的人机交互入口</li>
<li>实现无人值守运行</li>
</ul>
<p>在工业场景中，Kiosk 模式常作为 <strong>设备操作入口、监控终端、数据采集界面</strong> 的基础运行环境。</p>
<hr>
<h2 id="二、工业领域应用场景"><a href="#二、工业领域应用场景" class="headerlink" title="二、工业领域应用场景"></a>二、工业领域应用场景</h2><h3 id="1-HMI-操作终端"><a href="#1-HMI-操作终端" class="headerlink" title="1. HMI 操作终端"></a>1. HMI 操作终端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLC → SCADA/HMI → Kiosk终端显示</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>固定操作界面</li>
<li>防误触</li>
<li>设备控制隔离</li>
<li>7×24 运行</li>
</ul>
<p>应用：</p>
<ul>
<li>产线控制台</li>
<li>工业触摸屏</li>
<li>设备操作站</li>
</ul>
<hr>
<h3 id="2-工业监控大屏"><a href="#2-工业监控大屏" class="headerlink" title="2. 工业监控大屏"></a>2. 工业监控大屏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据采集 → 后端服务 → Web可视化 → Kiosk显示</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>浏览器全屏运行</li>
<li>自动刷新</li>
<li>无人工维护</li>
<li>多屏展示</li>
</ul>
<p>应用：</p>
<ul>
<li>生产监控中心</li>
<li>能耗监控</li>
<li>MES 看板</li>
<li>设备状态墙</li>
</ul>
<hr>
<h3 id="3-自助操作终端"><a href="#3-自助操作终端" class="headerlink" title="3. 自助操作终端"></a>3. 自助操作终端</h3><p>特点：</p>
<ul>
<li>无键盘鼠标</li>
<li>触摸交互</li>
<li>权限隔离</li>
<li>流程固定</li>
</ul>
<p>应用：</p>
<ul>
<li>工厂登记终端</li>
<li>设备自检终端</li>
<li>参数配置站</li>
</ul>
<hr>
<h3 id="4-边缘计算网关控制台"><a href="#4-边缘计算网关控制台" class="headerlink" title="4. 边缘计算网关控制台"></a>4. 边缘计算网关控制台</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传感器 → 边缘网关 → 本地Kiosk界面</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>本地离线运行</li>
<li>实时控制</li>
<li>无需云依赖</li>
<li>工业现场部署</li>
</ul>
<hr>
<h2 id="三、工业-Kiosk-架构设计"><a href="#三、工业-Kiosk-架构设计" class="headerlink" title="三、工业 Kiosk 架构设计"></a>三、工业 Kiosk 架构设计</h2><p>工业场景通常采用 <strong>三层架构</strong>。</p>
<hr>
<h3 id="1️⃣-整体架构图（SVG）"><a href="#1️⃣-整体架构图（SVG）" class="headerlink" title="1️⃣ 整体架构图（SVG）"></a>1️⃣ 整体架构图（SVG）</h3><p>下面为工业 Kiosk 标准架构。<br><img src="/2026/02/23/kiosk/kiosk-1.png" alt="kiosk-1.png"></p>
<hr>
<h3 id="2️⃣-软件层结构"><a href="#2️⃣-软件层结构" class="headerlink" title="2️⃣ 软件层结构"></a>2️⃣ 软件层结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────┐</span><br><span class="line">│ UI 应用层        │  Web / HMI / Dashboard</span><br><span class="line">├─────────────────┤</span><br><span class="line">│ Kiosk 控制层     │  锁屏 / 权限 / 进程控制</span><br><span class="line">├─────────────────┤</span><br><span class="line">│ 操作系统层       │  Linux / Windows / Android</span><br><span class="line">├─────────────────┤</span><br><span class="line">│ 工业设备接口层   │  PLC / Modbus / OPC UA</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、实现模式（重点）"><a href="#四、实现模式（重点）" class="headerlink" title="四、实现模式（重点）"></a>四、实现模式（重点）</h2><p>工业场景主要有 4 种实现方式。</p>
<hr>
<h3 id="1-浏览器-Kiosk-模式（最常用）"><a href="#1-浏览器-Kiosk-模式（最常用）" class="headerlink" title="1. 浏览器 Kiosk 模式（最常用）"></a>1. 浏览器 Kiosk 模式（最常用）</h3><p>适用于：</p>
<ul>
<li>Web SCADA</li>
<li>MES 看板</li>
<li>可视化大屏</li>
</ul>
<h4 id="Linux-实现"><a href="#Linux-实现" class="headerlink" title="Linux 实现"></a>Linux 实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chromium --kiosk http://localhost:8080</span><br></pre></td></tr></table></figure>

<p>系统启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/xdg/lxsession/LXDE/autostart</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@chromium --kiosk http://localhost</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>实现简单</li>
<li>易维护</li>
<li>支持远程更新</li>
</ul>
<hr>
<h3 id="2-操作系统级锁定"><a href="#2-操作系统级锁定" class="headerlink" title="2. 操作系统级锁定"></a>2. 操作系统级锁定</h3><p>适用于：</p>
<ul>
<li>工业触摸屏</li>
<li>固定控制终端</li>
</ul>
<h4 id="Windows-Assigned-Access"><a href="#Windows-Assigned-Access" class="headerlink" title="Windows Assigned Access"></a>Windows Assigned Access</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置 → 账户 → 家庭和其他用户 → Kiosk</span><br></pre></td></tr></table></figure>

<p>能力：</p>
<ul>
<li>单应用运行</li>
<li>禁止任务管理器</li>
<li>限制系统访问</li>
</ul>
<hr>
<h3 id="3-自定义启动壳（工业级）"><a href="#3-自定义启动壳（工业级）" class="headerlink" title="3. 自定义启动壳（工业级）"></a>3. 自定义启动壳（工业级）</h3><p>适用于：</p>
<ul>
<li>高安全工业系统</li>
<li>嵌入式设备</li>
</ul>
<p>Linux 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd → 启动自定义UI</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/my-ui</span><br><span class="line"><span class="attr">Restart</span>=always</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>无桌面环境</li>
<li>资源占用低</li>
<li>完全可控</li>
</ul>
<hr>
<h3 id="4-容器化-Kiosk（现代工业架构）"><a href="#4-容器化-Kiosk（现代工业架构）" class="headerlink" title="4. 容器化 Kiosk（现代工业架构）"></a>4. 容器化 Kiosk（现代工业架构）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker → UI服务 → 浏览器Kiosk</span><br></pre></td></tr></table></figure>

<p>优势：</p>
<ul>
<li>快速部署</li>
<li>远程更新</li>
<li>与边缘计算结合</li>
</ul>
<hr>
<h2 id="五、关键工程问题"><a href="#五、关键工程问题" class="headerlink" title="五、关键工程问题"></a>五、关键工程问题</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul>
<li>自动重启</li>
<li>Watchdog</li>
<li>断电恢复</li>
</ul>
<hr>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul>
<li>禁止退出</li>
<li>USB限制</li>
<li>权限控制</li>
<li>网络隔离</li>
</ul>
<hr>
<h3 id="运维能力"><a href="#运维能力" class="headerlink" title="运维能力"></a>运维能力</h3><ul>
<li>OTA更新</li>
<li>远程监控</li>
<li>日志上传</li>
</ul>
<hr>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>GPU加速</li>
<li>本地缓存</li>
<li>UI资源压缩</li>
</ul>
<hr>
<h2 id="六、工业级最佳实践架构"><a href="#六、工业级最佳实践架构" class="headerlink" title="六、工业级最佳实践架构"></a>六、工业级最佳实践架构</h2><p>推荐组合：</p>
<blockquote>
<p>Linux + Chromium Kiosk + systemd + Watchdog</p>
</blockquote>
<p>特点：</p>
<ul>
<li>启动快</li>
<li>稳定</li>
<li>易远程维护</li>
<li>适合工业现场</li>
</ul>
<hr>
<h2 id="七、典型技术栈"><a href="#七、典型技术栈" class="headerlink" title="七、典型技术栈"></a>七、典型技术栈</h2><table>
<thead>
<tr>
<th>层</th>
<th>技术</th>
</tr>
</thead>
<tbody><tr>
<td>UI</td>
<td>Vue &#x2F; React &#x2F; SCADA</td>
</tr>
<tr>
<td>通信</td>
<td>OPC UA &#x2F; MQTT &#x2F; Modbus</td>
</tr>
<tr>
<td>边缘</td>
<td>Node &#x2F; Java &#x2F; Python</td>
</tr>
<tr>
<td>系统</td>
<td>Linux &#x2F; Windows IoT</td>
</tr>
<tr>
<td>运维</td>
<td>Docker &#x2F; OTA</td>
</tr>
</tbody></table>
<hr>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>工业 Kiosk 模式本质是：</p>
<blockquote>
<p>可控的人机交互入口 + 稳定运行环境 + 安全隔离</p>
</blockquote>
<p>其价值：</p>
<ul>
<li>降低误操作风险</li>
<li>提升工业系统稳定性</li>
<li>实现无人值守</li>
<li>提供统一操作入口</li>
</ul>
<p>在工业数字化与边缘计算体系中，Kiosk 已成为标准交互形态。</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.ourexists.site">OUREXISTS</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.ourexists.site/2026/02/23/kiosk/">https://blog.ourexists.site/2026/02/23/kiosk/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.ourexists.site" target="_blank">OUREXISTS的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B7%A5%E4%B8%9A%E5%8C%96/">工业化</a></div><div class="post-share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_facebook_messenger"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async="async" src="https://static.addtoany.com/menu/page.js"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/shouk.jpg" target="_blank"><img class="post-qr-code-img" src="/img/shouk.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/02/25/ota/" title="🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）"><img class="cover" src="/img/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）</div></div><div class="info-2"><div class="info-item-1">一、什么是 OTA 升级？OTA（Over-The-Air）是指通过网络远程为设备更新：  固件（Firmware） 应用程序 配置文件 AI 模型 容器镜像  在工业 IoT 场景中，OTA 是设备生命周期管理的核心能力。 没有 OTA 的工业系统，基本无法规模化运营。  二、工业 OTA 的典型应用场景2.1 大规模设备部署升级场景 工厂部署 500 台边缘网关 设备厂家售出 3000 台控制设备 工业终端批量更新  传统方式：人工维护 → 成本极高OTA： 远程一键升级 2.2 安全漏洞修复例如：   OpenSSL 漏洞 Linux 内核漏洞 Web 管理后台漏洞  工业设备长期运行，一旦存在漏洞风险极大。 OTA 可实现：  快速补丁下发 紧急修复  2.3 新功能远程发布 新增 PLC 协议支持 更新 AI 预测模型 修改设备逻辑  2.4 工业终端远程应用更新适用于：  工业触摸屏 Kiosk 终端 产线操作设备  典型方案参考：  Huawei 工业终端管理 42Gears MDM 系统    三、工业 OTA 的核心优势✅ 降低运维成本  减少现场维护 降低人工...</div></div></div></a><a class="pagination-related" href="/2026/01/30/omes/" title="适用于工业化中小项目场景的设备管理系统OMES"><img class="cover" src="/img/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">适用于工业化中小项目场景的设备管理系统OMES</div></div><div class="info-2"><div class="info-item-1">一、行业背景与问题定义在工业数字化与工业互联网持续深化的背景下，中小型及规模化工业项目对设备全生命周期管理（EAM）、运行状态监控（O&amp;M）、过程数据采集（DAQ）以及多终端协同管理的需求日益增强。微信小程序、移动APP 与 Web 管理平台已逐步成为工业信息化的标准交互形态。 当前市场主流解决方案多由设备厂商主导构建，其设备云平台在商业模式与技术架构上大致可分为以下几类： 1. 厂商云平台的典型模式 平台免费 + 设备溢价模式：通过提高设备单价覆盖平台运营成本； 设备原价 + 平台阶梯收费模式：按设备接入规模收费，免费额度通常难以覆盖真实项目规模。  2. 现有技术路线分析（1）基于本地 SCADA 的设备管理系统 优势：  组态画面高度可定制，贴合工艺流程； 数据本地存储，信息安全性高。    局限：  开发与维护成本高； 跨厂商设备接入能力弱； 组态渲染性能瓶颈明显，难以支撑大规模设备场景。   适用范围：小型项目（&lt;100 台设备）。 （2）基于云端 SCADA 的设备管理平台 特点：在本地 SCADA 基础上引入云端集中管理； 风险：核心生产数据需上云，存...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/30/omes/" title="适用于工业化中小项目场景的设备管理系统OMES"><img class="cover" src="/img/bg.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-30</div><div class="info-item-2">适用于工业化中小项目场景的设备管理系统OMES</div></div><div class="info-2"><div class="info-item-1">一、行业背景与问题定义在工业数字化与工业互联网持续深化的背景下，中小型及规模化工业项目对设备全生命周期管理（EAM）、运行状态监控（O&amp;M）、过程数据采集（DAQ）以及多终端协同管理的需求日益增强。微信小程序、移动APP 与 Web 管理平台已逐步成为工业信息化的标准交互形态。 当前市场主流解决方案多由设备厂商主导构建，其设备云平台在商业模式与技术架构上大致可分为以下几类： 1. 厂商云平台的典型模式 平台免费 + 设备溢价模式：通过提高设备单价覆盖平台运营成本； 设备原价 + 平台阶梯收费模式：按设备接入规模收费，免费额度通常难以覆盖真实项目规模。  2. 现有技术路线分析（1）基于本地 SCADA 的设备管理系统 优势：  组态画面高度可定制，贴合工艺流程； 数据本地存储，信息安全性高。    局限：  开发与维护成本高； 跨厂商设备接入能力弱； 组态渲染性能瓶颈明显，难以支撑大规模设备场景。   适用范围：小型项目（&lt;100 台设备）。 （2）基于云端 SCADA 的设备管理平台 特点：在本地 SCADA 基础上引入云端集中管理； 风险：核心生产数据需上云，存...</div></div></div></a><a class="pagination-related" href="/2026/02/25/ota/" title="🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）"><img class="cover" src="/img/bg.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-26</div><div class="info-item-2">🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）</div></div><div class="info-2"><div class="info-item-1">一、什么是 OTA 升级？OTA（Over-The-Air）是指通过网络远程为设备更新：  固件（Firmware） 应用程序 配置文件 AI 模型 容器镜像  在工业 IoT 场景中，OTA 是设备生命周期管理的核心能力。 没有 OTA 的工业系统，基本无法规模化运营。  二、工业 OTA 的典型应用场景2.1 大规模设备部署升级场景 工厂部署 500 台边缘网关 设备厂家售出 3000 台控制设备 工业终端批量更新  传统方式：人工维护 → 成本极高OTA： 远程一键升级 2.2 安全漏洞修复例如：   OpenSSL 漏洞 Linux 内核漏洞 Web 管理后台漏洞  工业设备长期运行，一旦存在漏洞风险极大。 OTA 可实现：  快速补丁下发 紧急修复  2.3 新功能远程发布 新增 PLC 协议支持 更新 AI 预测模型 修改设备逻辑  2.4 工业终端远程应用更新适用于：  工业触摸屏 Kiosk 终端 产线操作设备  典型方案参考：  Huawei 工业终端管理 42Gears MDM 系统    三、工业 OTA 的核心优势✅ 降低运维成本  减少现场维护 降低人工...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">OUREXISTS</div><div class="author-info-description">一个热爱摄影的软件工程师</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ourexists"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ourexists" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">微信联系方式[ty434713950]</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%B8%9A%E9%A2%86%E5%9F%9F-Kiosk-%E6%A8%A1%E5%BC%8F%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text">工业领域 Kiosk 模式技术架构与实现实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Kiosk-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">一、什么是 Kiosk 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B7%A5%E4%B8%9A%E9%A2%86%E5%9F%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">二、工业领域应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HMI-%E6%93%8D%E4%BD%9C%E7%BB%88%E7%AB%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. HMI 操作终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A5%E4%B8%9A%E7%9B%91%E6%8E%A7%E5%A4%A7%E5%B1%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 工业监控大屏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E5%8A%A9%E6%93%8D%E4%BD%9C%E7%BB%88%E7%AB%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 自助操作终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%BD%91%E5%85%B3%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 边缘计算网关控制台</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B7%A5%E4%B8%9A-Kiosk-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">三、工业 Kiosk 架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE%EF%BC%88SVG%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1️⃣ 整体架构图（SVG）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E8%BD%AF%E4%BB%B6%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">2️⃣ 软件层结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">四、实现模式（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8-Kiosk-%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 浏览器 Kiosk 模式（最常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Linux 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%A7%E9%94%81%E5%AE%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 操作系统级锁定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows-Assigned-Access"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Windows Assigned Access</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%A3%B3%EF%BC%88%E5%B7%A5%E4%B8%9A%E7%BA%A7%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 自定义启动壳（工业级）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%B9%E5%99%A8%E5%8C%96-Kiosk%EF%BC%88%E7%8E%B0%E4%BB%A3%E5%B7%A5%E4%B8%9A%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 容器化 Kiosk（现代工业架构）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%85%B3%E9%94%AE%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">五、关键工程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">稳定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.5.2.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E8%83%BD%E5%8A%9B"><span class="toc-number">1.5.3.</span> <span class="toc-text">运维能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.4.</span> <span class="toc-text">性能优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%9E%B6%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">六、工业级最佳实践架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%85%B8%E5%9E%8B%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.7.</span> <span class="toc-text">七、典型技术栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">八、总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/25/ota/" title="🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）"><img src="/img/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）"/></a><div class="content"><a class="title" href="/2026/02/25/ota/" title="🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）">🏭 工业物联网中的 OTA 升级技术实践（架构 + 场景 + 实现）</a><time datetime="2026-02-25T16:00:00.000Z" title="发表于 2026-02-26 00:00:00">2026-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/02/23/kiosk/" title="工业终端单应用锁屏实现（工业 Kiosk 模式应用）"><img src="/img/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="工业终端单应用锁屏实现（工业 Kiosk 模式应用）"/></a><div class="content"><a class="title" href="/2026/02/23/kiosk/" title="工业终端单应用锁屏实现（工业 Kiosk 模式应用）">工业终端单应用锁屏实现（工业 Kiosk 模式应用）</a><time datetime="2026-02-23T16:00:00.000Z" title="发表于 2026-02-24 00:00:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/30/omes/" title="适用于工业化中小项目场景的设备管理系统OMES"><img src="/img/bg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="适用于工业化中小项目场景的设备管理系统OMES"/></a><div class="content"><a class="title" href="/2026/01/30/omes/" title="适用于工业化中小项目场景的设备管理系统OMES">适用于工业化中小项目场景的设备管理系统OMES</a><time datetime="2026-01-30T04:00:00.000Z" title="发表于 2026-01-30 12:00:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/24/oauth2/" title="Springboot3生态下OAuth2的生态搭建"><img src="/img/springboot.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot3生态下OAuth2的生态搭建"/></a><div class="content"><a class="title" href="/2025/08/24/oauth2/" title="Springboot3生态下OAuth2的生态搭建">Springboot3生态下OAuth2的生态搭建</a><time datetime="2025-08-24T16:00:00.000Z" title="发表于 2025-08-25 00:00:00">2025-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/09/gallery/" title="简单易懂的本地云图库搭建"><img src="/img/yw.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单易懂的本地云图库搭建"/></a><div class="content"><a class="title" href="/2025/06/09/gallery/" title="简单易懂的本地云图库搭建">简单易懂的本地云图库搭建</a><time datetime="2025-06-09T12:06:05.000Z" title="发表于 2025-06-09 20:06:05">2025-06-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/top.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By OUREXISTS</span></div><div class="footer_custom_text">soulitude in aestheticsrn</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'ourexists/ourexists.github.io',
      'data-repo-id': 'R_kgDOO11h5A',
      'data-category-id': 'DIC_kwDOO11h5M4CrBxT',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>